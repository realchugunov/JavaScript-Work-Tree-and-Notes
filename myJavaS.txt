#ES6
    ECMAScript, or ES, is a standardized version of JavaScript. Because all major browsers follow this specification, the terms ECMAScript and JavaScript are interchangeable.

    Most of the JavaScript you've learned up to this point was in ES5 (ECMAScript 5), which was finalized in 2009. While you can still write programs in ES5, JavaScript is constantly evolving, and 
    new features are released every year.

    ES6, released in 2015, added many powerful new features to the language. In this course, you'll learn these new features, including arrow functions, destructuring, classes, promises, and 
    modules.

>Mutate an Array Declared with const<
    it is important to understand that objects (including arrays and functions) assigned to a variable using const are still mutable. Using the const declaration only prevents reassignment of 
    the variable identifier.

        const s = [5, 6, 7];
        s = [1, 2, 3];
        s[2] = 45;
        console.log(s);

    s = [1, 2, 3] will result in an error. After commenting out that line, the console.log will display the value [5, 6, 45].

    As you can see, you can mutate the object [5, 6, 7] itself and the variable s will still point to the altered array [5, 6, 45]. Like all arrays, the array elements in s are mutable, 
    but because const was used, you cannot use the variable identifier s to point to a different array using the assignment operator.

>Prevent Object Mutation<
    As seen in the previous challenge, const declaration alone doesn't really protect your data from mutation. To ensure your data doesn't change, JavaScript provides a function Object.freeze 
    to prevent data mutation.

    Any attempt at changing the object will be rejected, with an error thrown if the script is running in strict mode.

        let obj = {
        name:"FreeCodeCamp",
        review:"Awesome"
        };
        Object.freeze(obj);
        obj.review = "bad";
        obj.newProp = "Test";
        console.log(obj); 

    The obj.review and obj.newProp assignments will result in errors, because our editor runs in strict mode by default, and the console will display the value 
    { name: "FreeCodeCamp", review: "Awesome" }.

>Use Arrow Functions to Write Concise Anonymous Functions<
    In JavaScript, we often don't need to name our functions, especially when passing a function as an argument to another function. Instead, we create inline functions. We don't need to name 
    these functions because we do not reuse them anywhere else.

    To achieve this, we often use the following syntax:

        const myFunc = function() {
        const myVar = "value";
        return myVar;
        }

    ES6 provides us with the syntactic sugar to not have to write anonymous functions this way. Instead, you can use arrow function syntax:

        const myFunc = () => {
        const myVar = "value";
        return myVar;
        }

    When there is no function body, and only a return value, arrow function syntax allows you to omit the keyword return as well as the brackets surrounding the code. This helps simplify 
    smaller functions into one-line statements:

        const myFunc = () => "value";

    This code will still return the string value by default.

>Write Arrow Functions with Parameters<
    Just like a regular function, you can pass arguments into an arrow function.

        const doubler = (item) => item * 2;
        doubler(4);

    doubler(4) would return the value 8.

    If an arrow function has a single parameter, the parentheses enclosing the parameter may be omitted.

        const doubler = item => item * 2;

    It is possible to pass more than one argument into an arrow function.

        const multiplier = (item, multi) => item * multi;
        multiplier(4, 2);

    multiplier(4, 2) would return the value 8.

>Set Default Parameters for Your Functions<
    In order to help us create more flexible functions, ES6 introduces default parameters for functions.

    Check out this code:

    const greeting = (name = "Anonymous") => "Hello " + name;

        console.log(greeting("John"));
        console.log(greeting());

    The console will display the strings Hello John and Hello Anonymous.

    The default parameter kicks in when the argument is not specified (it is undefined). As you can see in the example above, the parameter name will receive its default value Anonymous when 
    you do not provide a value for the parameter. You can add default values for as many parameters as you want.

>Use the Rest Parameter with Function Parameters<
    In order to help us create more flexible functions, ES6 introduces the rest parameter for function parameters. With the rest parameter, you can create functions that take a variable number 
    of arguments. These arguments are stored in an array that can be accessed later from inside the function.

    Check out this code:

        function howMany(...args) {
        return "You have passed " + args.length + " arguments.";
        }
        console.log(howMany(0, 1, 2));
        console.log(howMany("string", null, [1, 2, 3], { }));

    The console would display the strings You have passed 3 arguments. and You have passed 4 arguments..

    The rest parameter eliminates the need to use the arguments object and allows us to use array methods on the array of parameters passed to the function howMany.

>Use the Spread Operator to Evaluate Arrays In-Place<
    ES6 introduces the spread operator, which allows us to expand arrays and other expressions in places where multiple parameters or elements are expected.

    The ES5 code below uses apply() to compute the maximum value in an array:

        var arr = [6, 89, 3, 45];
        var maximus = Math.max.apply(null, arr);
        maximus would have a value of 89.

    We had to use Math.max.apply(null, arr) because Math.max(arr) returns NaN. Math.max() expects comma-separated arguments, but not an array. The spread operator makes this syntax much better 
    to read and maintain.

        const arr = [6, 89, 3, 45];
        const maximus = Math.max(...arr);
        maximus would have a value of 89.

    ...arr returns an unpacked array. In other words, it spreads the array. However, the spread operator only works in-place, like in an argument to a function or in an array literal. For 
    example:

        const spreaded = [...arr];
    However, the following code will not work:

        const spreaded = ...arr;

>Use Destructuring Assignment to Extract Values from Objects<
    Destructuring assignment is special syntax introduced in ES6, for neatly assigning values taken directly from an object.

    Consider the following ES5 code:

        const user = { name: 'John Doe', age: 34 };

        const name = user.name;
        const age = user.age;

    name would have a value of the string John Doe, and age would have the number 34.

    Here's an equivalent assignment statement using the ES6 destructuring syntax:

        const { name, age } = user;

    Again, name would have a value of the string John Doe, and age would have the number 34.

    Here, the name and age variables will be created and assigned the values of their respective values from the user object. You can see how much cleaner this is.

    You can extract as many or few values from the object as you want.

>Use Destructuring Assignment to Assign Variables from Objects<
    Destructuring allows you to assign a new variable name when extracting values. You can do this by putting the new name after a colon when assigning the value.

    Using the same object from the last example:

    const user = { name: 'John Doe', age: 34 };

    Here's how you can give new variable names in the assignment:

    const { name: userName, age: userAge } = user;

    You may read it as "get the value of user.name and assign it to a new variable named userName" and so on. The value of userName would be the string John Doe, and the value of userAge 
    would be the number 34.

>Use Destructuring Assignment to Assign Variables from Nested Objects<
    You can use the same principles from the previous two lessons to destructure values from nested objects.

    Using an object similar to previous examples:

        const user = {
        johnDoe: { 
            age: 34,
            email: 'johnDoe@freeCodeCamp.com'
        }
        };

    Here's how to extract the values of object properties and assign them to variables with the same name:

        const { johnDoe: { age, email }} = user;

    And here's how you can assign an object properties' values to variables with different names:

        const { johnDoe: { age: userAge, email: userEmail }} = user;

>Use Destructuring Assignment to Assign Variables from Arrays<
    ES6 makes destructuring arrays as easy as destructuring objects.

    One key difference between the spread operator and array destructuring is that the spread operator unpacks all contents of an array into a comma-separated list. Consequently, you cannot 
    pick or choose which elements you want to assign to variables.

    Destructuring an array lets us do exactly that:

        const [a, b] = [1, 2, 3, 4, 5, 6];
        console.log(a, b);

    The console will display the values of a and b as 1, 2.

    The variable a is assigned the first value of the array, and b is assigned the second value of the array. We can also access the value at any index in an array with destructuring by using 
    commas to reach the desired index:

        const [a, b,,, c] = [1, 2, 3, 4, 5, 6];
        console.log(a, b, c);

    The console will display the values of a, b, and c as 1, 2, 5.

>Use Destructuring Assignment to Pass an Object as a Function's Parameters<
    In some cases, you can destructure the object in a function argument itself.

    Consider the code below:

        const profileUpdate = (profileData) => {
        const { name, age, nationality, location } = profileData;

        }

    This effectively destructures the object sent into the function. This can also be done in-place:

        const profileUpdate = ({ name, age, nationality, location }) => {

        }

    When profileData is passed to the above function, the values are destructured from the function parameter for use within the function.

>Create Strings using Template Literals<
    A new feature of ES6 is the template literal. This is a special type of string that makes creating complex strings easier.

    Template literals allow you to create multi-line strings and to use string interpolation features to create strings.

    Consider the code below:

        const person = {
        name: "Zodiac Hasbro",
        age: 56
        };

        const greeting = `Hello, my name is ${person.name}!
        I am ${person.age} years old.`;

        console.log(greeting);

    The console will display the strings Hello, my name is Zodiac Hasbro! and I am 56 years old..

    A lot of things happened there. Firstly, the example uses backticks (`), not quotes (' or "), to wrap the string. Secondly, notice that the string is multi-line, both in the code and the 
    output. This saves inserting \n within strings. The ${variable} syntax used above is a placeholder. Basically, you won't have to use concatenation with the + operator anymore. To add 
    variables to strings, you just drop the variable in a template string and wrap it with ${ and }. Similarly, you can include other expressions in your string literal, for example ${a + b}. 
    This new way of creating strings gives you more flexibility to create robust strings.

>Write Concise Object Literal Declarations Using Object Property Shorthand<
    ES6 adds some nice support for easily defining object literals.

    Consider the following code:

        const getMousePosition = (x, y) => ({
        x: x,
        y: y
        });

    getMousePosition is a simple function that returns an object containing two properties. ES6 provides the syntactic sugar to eliminate the redundancy of having to write x: x. You can 
    simply write x once, and it will be converted tox: x (or something equivalent) under the hood. Here is the same function from above rewritten to use this new syntax:

        const getMousePosition = (x, y) => ({ x, y });

>Write Concise Declarative Functions with ES6<
    When defining functions within objects in ES5, we have to use the keyword function as follows:

        const person = {
        name: "Taylor",
        sayHello: function() {
            return `Hello! My name is ${this.name}.`;
        }
        };

    With ES6, you can remove the function keyword and colon altogether when defining functions in objects. Here's an example of this syntax:

        const person = {
        name: "Taylor",
        sayHello() {
            return `Hello! My name is ${this.name}.`;
        }
        };

>Use class Syntax to Define a Constructor Function<
    ES6 provides a new syntax to create objects, using the class keyword.

    In ES5, an object can be created by defining a constructor function and using the new keyword to instantiate the object.

    In ES6, a class declaration has a constructor method that is invoked with the new keyword. If the constructor method is not explicitly defined, then it is implicitly defined with no 
    arguments.

        // Explicit constructor
        class SpaceShuttle {
        constructor(targetPlanet) {
            this.targetPlanet = targetPlanet;
        }
        takeOff() {
            console.log("To " + this.targetPlanet + "!");
        }
        }

        // Implicit constructor 
        class Rocket {
        launch() {
            console.log("To the moon!");
        }
        }

        const zeus = new SpaceShuttle('Jupiter');
        // prints To Jupiter! in console
        zeus.takeOff();

        const atlas = new Rocket();
        // prints To the moon! in console
        atlas.launch();

    It should be noted that the class keyword declares a new function, to which a constructor is added. This constructor is invoked when new is called to create a new object.

    Note: UpperCamelCase should be used by convention for ES6 class names, as in SpaceShuttle used above.

    The constructor method is a special method for creating and initializing an object created with a class.

>Use getters and setters to Control Access to an Object<
    You can obtain values from an object and set the value of a property within an object.

    These are classically called getters and setters.

    Getter functions are meant to simply return (get) the value of an object's private variable to the user without the user directly accessing the private variable.

    Setter functions are meant to modify (set) the value of an object's private variable based on the value passed into the setter function. This change could involve calculations, 
    or even overwriting the previous value completely.

        class Book {
        constructor(author) {
            this._author = author;
        }
        // getter
        get writer() {
            return this._author;
        }
        // setter
        set writer(updatedAuthor) {
            this._author = updatedAuthor;
        }
        }
        const novel = new Book('anonymous');
        console.log(novel.writer);
        novel.writer = 'newAuthor';
        console.log(novel.writer);
    The console would display the strings anonymous and newAuthor.

    Notice the syntax used to invoke the getter and setter. They do not even look like functions. Getters and setters are important because they hide internal implementation details.

    Note: It is convention to precede the name of a private variable with an underscore (_). However, the practice itself does not make a variable private.

>Create a Module Script<
    JavaScript started with a small role to play on an otherwise mostly HTML web. Today, it’s huge, and some websites are built almost entirely with JavaScript. In order to make 
    JavaScript more modular, clean, and maintainable; ES6 introduced a way to easily share code among JavaScript files. This involves exporting parts of a file for use in one or 
    more other files, and importing the parts you need, where you need them. In order to take advantage of this functionality, you need to create a script in your HTML document 
    with a type of module. Here’s an example:

        <script type="module" src="filename.js"></script>

    A script that uses this module type can now use the import and export features you will learn about in the upcoming challenges.

>Create a JavaScript Promise<
    A promise in JavaScript is exactly what it sounds like - you use it to make a promise to do something, usually asynchronously. When the task completes, 
    you either fulfill your promise or fail to do so. Promise is a constructor function, so you need to use the new keyword to create one. It takes a function, 
    as its argument, with two parameters - resolve and reject. These are methods used to determine the outcome of the promise. The syntax looks like this:

        const myPromise = new Promise((resolve, reject) => {

        });

>Complete a Promise with resolve and reject<
    A promise has three states: pending, fulfilled, and rejected. The promise you created in the last challenge is forever stuck in the pending state 
    because you did not add a way to complete the promise. The resolve and reject parameters given to the promise argument are used to do this. resolve 
    is used when you want your promise to succeed, and reject is used when you want it to fail. These are methods that take an argument, as seen below.

        const myPromise = new Promise((resolve, reject) => {
        if(condition here) {
            resolve("Promise was fulfilled");
        } else {
            reject("Promise was rejected");
        }
        });

    The example above uses strings for the argument of these functions, but it can really be anything. Often, it might be an object, that you would use 
    data from, to put on your website or elsewhere.

>Handle a Fulfilled Promise with then<
    Promises are most useful when you have a process that takes an unknown amount of time in your code (i.e. something asynchronous), often a server 
    request. When you make a server request it takes some amount of time, and after it completes you usually want to do something with the response 
    from the server. This can be achieved by using the then method. The then method is executed immediately after your promise is fulfilled with 
    resolve. Here’s an example:

        myPromise.then(result => {
        
        });
    
    result comes from the argument given to the resolve method.

>Handle a Rejected Promise with catch<
    catch is the method used when your promise has been rejected. It is executed immediately after a promise's reject method is called. Here’s the syntax:

        myPromise.catch(error => {
        
        });
    
    error is the argument passed in to the reject method.

-----------------End of the ES6 Lesson ------------------ 

#Basic Data Structures
    Data can be stored and accessed in many ways. You already know some common JavaScript data structures — arrays and objects.

    In this Basic Data Structures course, you'll learn more about the differences between arrays and objects, and which to use in different situations. 
    You'll also learn how to use helpful JS methods like splice() and Object.keys() to access and manipulate data.

>Use an Array to Store a Collection of Data<
    The below is an example of the simplest implementation of an array data structure. This is known as a one-dimensional array, meaning it only has one 
    level, or that it does not have any other arrays nested within it. Notice it contains booleans, strings, and numbers, among other valid JavaScript 
    data types:

        let simpleArray = ['one', 2, 'three', true, false, undefined, null];
        console.log(simpleArray.length);

    The console.log call displays 7.

    All arrays have a length property, which as shown above, can be very easily accessed with the syntax Array.length. A more complex implementation of 
    an array can be seen below. This is known as a multi-dimensional array, or an array that contains other arrays. Notice that this array also 
    contains JavaScript objects, which we will examine very closely in our next section, but for now, all you need to know is that arrays are also 
    capable of storing complex objects.

        let complexArray = [
      [
        {
        one: 1,
        two: 2
        },
        {
        three: 3,
        four: 4
        }
      ],
      [
        {
        a: "a",
        b: "b"
        },
        {
        c: "c",
        d: "d"
        }
      ]
      ];

>Access an Array's Contents Using Bracket Notation<
    The fundamental feature of any data structure is, of course, the ability to not only store data, but to be able to retrieve that data on command. So, now that we've learned how to 
    create an array, let's begin to think about how we can access that array's information.

    When we define a simple array as seen below, there are 3 items in it:

        let ourArray = ["a", "b", "c"];
    
    In an array, each array item has an index. This index doubles as the position of that item in the array, and how you reference it. However, it is important to note, that JavaScript 
    arrays are zero-indexed, meaning that the first element of an array is actually at the zeroth position, not the first. In order to retrieve an element from an array we can enclose 
    an index in brackets and append it to the end of an array, or more commonly, to a variable which references an array object. This is known as bracket notation. For example, if we 
    want to retrieve the a from ourArray and assign it to a variable, we can do so with the following code:

        let ourVariable = ourArray[0];

    Now ourVariable has the value of a.

    In addition to accessing the value associated with an index, you can also set an index to a value using the same notation:

        ourArray[1] = "not b anymore";
    
    Using bracket notation, we have now reset the item at index 1 from the string b, to not b anymore. Now ourArray is ["a", "not b anymore", "c"].

>Add Items to an Array with push() and unshift()<
    An array's length, like the data types it can contain, is not fixed. Arrays can be defined with a length of any number of elements, and elements can be added or removed over time; 
    in other words, arrays are mutable. In this challenge, we will look at two methods with which we can programmatically modify an array: Array.push() and Array.unshift().

    Both methods take one or more elements as parameters and add those elements to the array the method is being called on; the push() method adds elements to the end of an array, and 
    unshift() adds elements to the beginning. Consider the following:

        let twentyThree = 'XXIII';
        let romanNumerals = ['XXI', 'XXII'];

        romanNumerals.unshift('XIX', 'XX');

    romanNumerals would have the value ['XIX', 'XX', 'XXI', 'XXII'].

        romanNumerals.push(twentyThree);
    
    romanNumerals would have the value ['XIX', 'XX', 'XXI', 'XXII', 'XXIII']. Notice that we can also pass variables, which allows us even greater flexibility in dynamically modifying 
    our array's data.

>Remove Items from an Array with pop() and shift()<
    Both push() and unshift() have corresponding methods that are nearly functional opposites: pop() and shift(). As you may have guessed by now, instead of adding, pop() removes an 
    element from the end of an array, while shift() removes an element from the beginning. The key difference between pop() and shift() and their cousins push() and unshift(), is 
    that neither method takes parameters, and each only allows an array to be modified by a single element at a time.

    Let's take a look:

        let greetings = ['whats up?', 'hello', 'see ya!'];

        greetings.pop();

    greetings would have the value ['whats up?', 'hello'].

    
    greetings.shift();
    
    greetings would have the value ['hello'].

    We can also return the value of the removed element with either method like this:

        let popped = greetings.pop();

    greetings would have the value [], and popped would have the value hello.

>Remove Items Using splice()<
    Ok, so we've learned how to remove elements from the beginning and end of arrays using shift() and pop(), but what if we want to remove an element from somewhere in the middle? Or 
    remove more than one element at once? Well, that's where splice() comes in. splice() allows us to do just that: remove any number of consecutive elements from anywhere in an array.

    splice() can take up to 3 parameters, but for now, we'll focus on just the first 2. The first two parameters of splice() are integers which represent indexes, or positions, of items 
    in the array that splice() is being called upon. And remember, arrays are zero-indexed, so to indicate the first element of an array, we would use 0. splice()'s first parameter 
    represents the index on the array from which to begin removing elements, while the second parameter indicates the number of elements to delete. For example:

        let array = ['today', 'was', 'not', 'so', 'great'];

        array.splice(2, 2);

    Here we remove 2 elements, beginning with the third element (at index 2). array would have the value ['today', 'was', 'great'].

    splice() not only modifies the array it's being called on, but it also returns a new array containing the value of the removed elements:

        let array = ['I', 'am', 'feeling', 'really', 'happy'];

        let newArray = array.splice(3, 2);

    newArray has the value ['really', 'happy'].    

>Add Items Using splice()<
    Remember in the last challenge we mentioned that splice() can take up to three parameters? Well, you can use the third parameter, comprised of one or more element(s), to add to the 
    array. This can be incredibly useful for quickly switching out an element, or a set of elements, for another.

        const numbers = [10, 11, 12, 12, 15];
        const startIndex = 3;
        const amountToDelete = 1;

        numbers.splice(startIndex, amountToDelete, 13, 14);
        console.log(numbers);

    The second occurrence of 12 is removed, and we add 13 and 14 at the same index. The numbers array would now be [ 10, 11, 12, 13, 14, 15 ].

    Here, we begin with an array of numbers. Then, we pass the following to splice(): The index at which to begin deleting elements (3), the number of elements to be deleted (1), and the 
    remaining arguments (13, 14) will be inserted starting at that same index. Note that there can be any number of elements (separated by commas) following amountToDelete, each of which 
    gets inserted.

>Copy Array Items Using slice()<
    The next method we will cover is slice(). Rather than modifying an array, slice() copies or extracts a given number of elements to a new array, leaving the array it is called 
    upon untouched. slice() takes only 2 parameters — the first is the index at which to begin extraction, and the second is the index at which to stop extraction (extraction will 
    occur up to, but not including the element at this index). Consider this:

        let weatherConditions = ['rain', 'snow', 'sleet', 'hail', 'clear'];

        let todaysWeather = weatherConditions.slice(1, 3);

    todaysWeather would have the value ['snow', 'sleet'], while weatherConditions would still have ['rain', 'snow', 'sleet', 'hail', 'clear'].

    In effect, we have created a new array by extracting elements from an existing array

>Copy an Array with the Spread Operator<
    While slice() allows us to be selective about what elements of an array to copy, among several other useful tasks, ES6's new spread operator allows us to easily copy all of an 
    array's elements, in order, with a simple and highly readable syntax. The spread syntax simply looks like this: ...

    In practice, we can use the spread operator to copy an array like so:

        let thisArray = [true, true, undefined, false, null];
        let thatArray = [...thisArray];

    thatArray equals [true, true, undefined, false, null]. thisArray remains unchanged and thatArray contains the same elements as thisArray.

>Combine Arrays with the Spread Operator<
    Another huge advantage of the spread operator is the ability to combine arrays, or to insert all the elements of one array into another, at any index. With more traditional syntaxes, 
    we can concatenate arrays, but this only allows us to combine arrays at the end of one, and at the start of another. Spread syntax makes the following operation extremely simple:

        let thisArray = ['sage', 'rosemary', 'parsley', 'thyme'];

        let thatArray = ['basil', 'cilantro', ...thisArray, 'coriander'];

    thatArray would have the value ['basil', 'cilantro', 'sage', 'rosemary', 'parsley', 'thyme', 'coriander'].

    Using spread syntax, we have just achieved an operation that would have been more complex and more verbose had we used traditional methods.

>Check For The Presence of an Element With indexOf()<
    Since arrays can be changed, or mutated, at any time, there's no guarantee about where a particular piece of data will be on a given array, or if that element even still exists. 
    Luckily, JavaScript provides us with another built-in method, indexOf(), that allows us to quickly and easily check for the presence of an element on an array. indexOf() takes an 
    element as a parameter, and when called, it returns the position, or index, of that element, or -1 if the element does not exist on the array.

    For example:

        let fruits = ['apples', 'pears', 'oranges', 'peaches', 'pears'];

        fruits.indexOf('dates');
        fruits.indexOf('oranges');
        fruits.indexOf('pears');

    indexOf('dates') returns -1, indexOf('oranges') returns 2, and indexOf('pears') returns 1 (the first index at which each element exists).

>Iterate Through All an Array's Items Using For Loops<
    Sometimes when working with arrays, it is very handy to be able to iterate through each item to find one or more elements that we might need, or to manipulate an array based on which 
    data items meet a certain set of criteria. JavaScript offers several built in methods that each iterate over arrays in slightly different ways to achieve different results 
    (such as every(), forEach(), map(), etc.), however the technique which is most flexible and offers us the greatest amount of control is a simple for loop.

    Consider the following:

        function greaterThanTen(arr) {
        let newArr = [];
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] > 10) {
            newArr.push(arr[i]);
            }
        }
        return newArr;
        }

        greaterThanTen([2, 12, 8, 14, 80, 0, 1]);
    
    Using a for loop, this function iterates through and accesses each element of the array, and subjects it to a simple test that we have created. In this way, we have easily and 
    programmatically determined which data items are greater than 10, and returned a new array, [12, 14, 80], containing those items.

>Add Key-Value Pairs to JavaScript Objects<
    At their most basic, objects are just collections of key-value pairs. In other words, they are pieces of data (values) mapped to unique identifiers called properties (keys). Take a 
    look at an example:

        const tekkenCharacter = {
        player: 'Hwoarang',
        fightingStyle: 'Tae Kwon Doe',
        human: true
        };

    The above code defines a Tekken video game character object called tekkenCharacter. It has three properties, each of which map to a specific value. If you want to add an additional 
    property, such as "origin", it can be done by assigning origin to the object:

        tekkenCharacter.origin = 'South Korea';

    This uses dot notation. If you were to observe the tekkenCharacter object, it will now include the origin property. Hwoarang also had distinct orange hair. You can add this property 
    with bracket notation by doing:

        tekkenCharacter['hair color'] = 'dyed orange';

    Bracket notation is required if your property has a space in it or if you want to use a variable to name the property. In the above case, the property is enclosed in quotes to denote 
    it as a string and will be added exactly as shown. Without quotes, it will be evaluated as a variable and the name of the property will be whatever value the variable is. Here's an 
    example with a variable:

        const eyes = 'eye color';

        tekkenCharacter[eyes] = 'brown';

    After adding all the examples, the object will look like this:

        {
        player: 'Hwoarang',
        fightingStyle: 'Tae Kwon Doe',
        human: true,
        origin: 'South Korea',
        'hair color': 'dyed orange',
        'eye color': 'brown'
        };

>Modify an Object Nested Within an Object<
    Now let's take a look at a slightly more complex object. Object properties can be nested to an arbitrary depth, and their values can be any type of data supported by JavaScript, 
    including arrays and even other objects. Consider the following:

        let nestedObject = {
        id: 28802695164,
        date: 'December 31, 2016',
        data: {
            totalUsers: 99,
            online: 80,
            onlineStatus: {
            active: 67,
            away: 13,
            busy: 8
            }
        }
        };

    nestedObject has three properties: id (value is a number), date (value is a string), and data (value is an object with its nested structure). While structures can quickly become complex, 
    we can still use the same notations to access the information we need. To assign the value 10 to the busy property of the nested onlineStatus object, we use dot notation to reference 
    the property:

        nestedObject.data.onlineStatus.busy = 10;

>Access Property Names with Bracket Notation<
    In the first object challenge we mentioned the use of bracket notation as a way to access property values using the evaluation of a variable. For instance, imagine that our foods 
    object is being used in a program for a supermarket cash register. We have some function that sets the selectedFood and we want to check our foods object for the presence of that 
    food. This might look like:

        let selectedFood = getCurrentFood(scannedItem);
        let inventory = foods[selectedFood];

    This code will evaluate the value stored in the selectedFood variable and return the value of that key in the foods object, or undefined if it is not present. Bracket notation is 
    very useful because sometimes object properties are not known before runtime or we need to access them in a more dynamic way.

    Example:
        We've defined a function, checkInventory, which receives a scanned item as an argument. Return the current value of the scannedItem key in the foods object. You can assume 
        that only valid keys will be provided as an argument to checkInventory.

            let foods = {
            apples: 25,
            oranges: 32,
            plums: 28,
            bananas: 13,
            grapes: 35,
            strawberries: 27
            };

            function checkInventory(scannedItem) {
            // Only change code below this line
            return foods[scannedItem]  // you will add this < code 
            // Only change code above this line
            }

            console.log(checkInventory("apples"));

            console.log will show 25.

>Use the delete Keyword to Remove Object Properties<
    Now you know what objects are and their basic features and advantages. In short, they are key-value stores which provide a flexible, intuitive way to structure data, and, they 
    provide very fast lookup time. Throughout the rest of these challenges, we will describe several common operations you can perform on objects so you can become comfortable applying 
    these useful data structures in your programs.

    In earlier challenges, we have both added to and modified an object's key-value pairs. Here we will see how we can remove a key-value pair from an object.

    Let's revisit our foods object example one last time. If we wanted to remove the apples key, we can remove it by using the delete keyword like this:

        delete foods.apples;

>Check if an Object has a Property<
    Now we can add, modify, and remove keys from objects. But what if we just wanted to know if an object has a specific property? JavaScript provides us with two different ways to do this. One uses the hasOwnProperty() method and the other uses the in keyword. If we have an object users with a property of Alan, we could check for its presence in either of the following ways:

        users.hasOwnProperty('Alan');
        'Alan' in users;

    Both of these would return true.

>Iterate Through the Keys of an Object with a for...in Statement<
    
-------------------End of Basic Data Structures Lesson -------------------

#Basic Algorithm Scripting
    An algorithm is a series of step-by-step instructions that describe how to do something.
    To write an effective algorithm, it helps to break a problem down into smaller parts and think carefully about how to solve each part with code.
    In this course, you'll learn the fundamentals of algorithmic thinking by writing algorithms that do everything from converting temperatures to handling complex 2D arrays.

>How to use JavaScript Array.prototype.map()<
    The method map of the Array prototype allows you to grab a hold of each element inside an array and apply a function to them. After map finishes iterating through the array, 
    it will return a new array with the results of applying the function to the aforementioned elements.

    The syntax is as follows:
        myAwesomeArray.map(myAwesomeFunction)

    Since map doesn’t mutate the original array, it should be used as a value, stored inside a variable, passed in as a returned value inside a function (the most common case) and many 
    other things. Let’s learn a little bit of what this powerful function can do! Say we have an array of names and we want to create a new array with these names but UPPERCASED.

        var names = ["Leia", "Anakin", "Luke", "Obi Wan Kenobi"];
        var uppercaseNames = names.map(function(name) {
        return name.toUpperCase();
        };

        Now if we console.log(uppercaseNames) we will get this:

        Array(4) -> ["LEIA", "ANAKIN", "LUKE", "OBI WAN KENOBI"]

    But how does it work? Let’s dive more into it.

    Let’s talk about the callback parameters:

        The callback is the function that the Array.map() method accepts, it can be an anonymous function or an already declared function with the following parameters which, by the way, you can name as you please:

            1- currentValue: As the name suggest, it’s the current element of the array being evaluated and waiting for your function to replace it with a new value in the new array (same index of course).

            2- index: It equals to the numeric index of currentValue, say you are in “Anakin”, that means index, at the time, will equal to 1.

            3- array: The array that’s calling the method, in this case, it’s referring to names.

            Examples work better than loose explanations, now we can make our callback function turn.

            ["Leia", "Anakin", "Luke", "Obi Wan Kenobi"] 
            into 
            ["My name is Leia, I'm #1", "My name is Anakin, I'm #2", "My name is Luke, I'm #3", "And last but not less important, I'm #4 Obi Wan Kenobi"]

            Sounds interesting and complex huh? It’s actually not if you put the first two parameters to use.

                var jediMasters = ["Leia", "Anakin", "Luke", "Obi Wan Kenobi"];
                var jediMastersSayHi = jediMasters.map(function(jediName, jediIndex) {
                if (jediName === "Obi Wan Kenobi") {
                    return "And last but not less important, I'm #" + (jediIndex + 1) + " " + jediName;
                } else {
                    return "My name is " + jediName + ", I'm #" + (jediIndex + 1);
                }
                }); // We're done mapping, now console.log the whole thing.

>Array.prototype.sort()<
    The sort() method of Array instances sorts the elements of an array in place and returns the reference to the same array, now sorted. The default sort order is ascending, built 
    upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.

    The time and space complexity of the sort cannot be guaranteed as it depends on the implementation.

    To sort the elements in an array without mutating the original array, use toSorted().



   

>Define a Constructor Function<
    Constructors are functions that create new objects. They define properties and behaviors that will belong to the new object. Think of them as a 
    blueprint for the creation of new objects.

    Here is an example of a constructor:

        function Bird() {
        this.name = "Albert";
        this.color = "blue";
        this.numLegs = 2;
        }
    
            This constructor defines a Bird object with properties name, color, and numLegs set to Albert, blue, and 2, respectively. Constructors 
            follow a few conventions:

               * Constructors are defined with a capitalized name to distinguish them from other functions that are not constructors.
               * Constructors use the keyword 'this' to set properties of the object they will create. Inside the constructor, this refers to the new 
                object it will create.

               * Constructors define properties and behaviors instead of returning a value as other functions might.

>Use a Constructor to Create Objects<

    Here's the Bird constructor from the previous challenge:

        function Bird() {
        this.name = "Albert";
        this.color  = "blue";
        this.numLegs = 2;
        }

        let blueBird = new Bird();

    NOTE: this inside the constructor always refers to the object being created.

    Notice that the new operator is used when calling a constructor. This tells JavaScript to create a new instance of Bird called blueBird. 
    Without the new operator, this inside the constructor would not point to the newly created object, giving unexpected results. Now blueBird has 
    all the properties defined inside the Bird constructor:

        blueBird.name;
        blueBird.color;
        blueBird.numLegs;
        Just like any other object, its properties can be accessed and modified:

        blueBird.name = 'Elvira';
        blueBird.name;

>Extend Constructors to Receive Arguments<
    The Bird and Dog constructors from the last challenge worked well. However, notice that all Birds that are created with the Bird constructor 
    are automatically named Albert, are blue in color, and have two legs. What if you want birds with different values for name and color? 
    It's possible to change the properties of each bird manually but that would be a lot of work:

        let swan = new Bird();
        swan.name = "Carlos";
        swan.color = "white";

    Suppose you were writing a program to keep track of hundreds or even thousands of different birds in an aviary. It would take a lot of time to 
    create all the birds, then change the properties to different values for every one. To more easily create different Bird objects, you can design 
    your Bird constructor to accept parameters:

        function Bird(name, color) {
        this.name = name;
        this.color = color;
        this.numLegs = 2;
        }

    Then pass in the values as arguments to define each unique bird into the Bird constructor: let cardinal = new Bird("Bruce", "red"); This gives a 
    new instance of Bird with name and color properties set to Bruce and red, respectively. The numLegs property is still set to 2. The cardinal has 
    these properties:

        cardinal.name
        cardinal.color
        cardinal.numLegs

    The constructor is more flexible. It's now possible to define the properties for each Bird at the time it is created, which is one way that 
    JavaScript constructors are so useful. They group objects together based on shared characteristics and behavior and define a blueprint that 
    automates their creation.

>Verify an Object's Constructor with 'instanceof'<

    Anytime a constructor function creates a new object, that object is said to be an instance of its constructor. JavaScript gives a convenient 
    way to verify this with the instanceof operator. instanceof allows you to compare an object to a constructor, returning true or false based on 
    whether or not that object was created with the constructor. Here's an example:

        let Bird = function(name, color) {
        this.name = name;
        this.color = color;
        this.numLegs = 2;
        }

        let crow = new Bird("Alexis", "black");

        crow instanceof Bird;

    This instanceof method would return true.

    If an object is created without using a constructor, instanceof will verify that it is not an instance of that constructor:

        let canary = {
        name: "Mildred",
        color: "Yellow",
        numLegs: 2
        };

        canary instanceof Bird;
    
    This instanceof method would return false.

>Understand Own Properties<

    In the following example, the Bird constructor defines two properties: name and numLegs:

        function Bird(name) {
        this.name = name;
        this.numLegs = 2;
        }

        let duck = new Bird("Donald");
        let canary = new Bird("Tweety");

    name and numLegs are called own properties, because they are defined directly on the instance object. That means that duck and canary each has its 
    own separate copy of these properties. In fact every instance of Bird will have its own copy of these properties. The following code adds all of 
    the own properties of duck to the array ownProps:

        let ownProps = [];

        for (let property in duck) {
        if(duck.hasOwnProperty(property)) {
            ownProps.push(property);
        }
        }

        console.log(ownProps);

    The console would display the value ["name", "numLegs"].

>Use Prototype Properties to Reduce Duplicate Code<

    Since numLegs will probably have the same value for all instances of Bird, you essentially have a duplicated variable numLegs inside each Bird instance.

    This may not be an issue when there are only two instances, but imagine if there are millions of instances. That would be a lot of duplicated variables.

    A better way is to use the prototype of Bird. Properties in the prototype are shared among ALL instances of Bird. Here's how to add numLegs to the Bird 
    prototype:

        Bird.prototype.numLegs = 2;

    Now all instances of Bird have the numLegs property.

        console.log(duck.numLegs);
        console.log(canary.numLegs);

    Since all instances automatically have the properties on the prototype, think of a prototype as a "recipe" for creating objects. Note that the prototype 
    for duck and canary is part of the Bird constructor as Bird.prototype.

>Iterate Over All Properties<

    You have now seen two kinds of properties: own properties and prototype properties. Own properties are defined directly on the object instance itself. And prototype properties are 
    defined on the prototype.

        function Bird(name) {
        this.name = name;  //own property
        }

        Bird.prototype.numLegs = 2; // prototype property

        let duck = new Bird("Donald");

    Here is how you add duck's own properties to the array ownProps and prototype properties to the array prototypeProps:

        let ownProps = [];
        let prototypeProps = [];

        for (let property in duck) {
        if(duck.hasOwnProperty(property)) {
            ownProps.push(property);
        } else {
            prototypeProps.push(property);
        }
        }

        console.log(ownProps);
        console.log(prototypeProps);

    console.log(ownProps) would display ["name"] in the console, and console.log(prototypeProps) would display ["numLegs"].

>Understand the Constructor Property<

    There is a special constructor property located on the object instances duck and beagle that were created in the previous challenges:

        let duck = new Bird();
        let beagle = new Dog();

        console.log(duck.constructor === Bird); 
        console.log(beagle.constructor === Dog);

    Both of these console.log calls would display true in the console.

    Note that the constructor property is a reference to the constructor function that created the instance. The advantage of the constructor property is that it's possible to check 
    for this property to find out what kind of object it is. Here's an example of how this could be used:

        function joinBirdFraternity(candidate) {
        if (candidate.constructor === Bird) {
            return true;
        } else {
            return false;
        }
        }

    Note: Since the constructor property can be overwritten (which will be covered in the next two challenges) it’s generally better to use the instanceof method to check the type of 
    an object.

>Change the Prototype to a New Object<

    Up until now you have been adding properties to the prototype individually:

        Bird.prototype.numLegs = 2;
        This becomes tedious after more than a few properties.

        Bird.prototype.eat = function() {
        console.log("nom nom nom");
        }

        Bird.prototype.describe = function() {
        console.log("My name is " + this.name);
        }

    A more efficient way is to set the prototype to a new object that already contains the properties. This way, the properties are added all at once:

        Bird.prototype = {
        numLegs: 2, 
        eat: function() {
            console.log("nom nom nom");
        },
        describe: function() {
            console.log("My name is " + this.name);
        }
        };

>Remember to Set the Constructor Property when Changing the Prototype<
    There is one crucial side effect of manually setting the prototype to a new object. It erases the constructor property! This property can be used to check which constructor 
    function created the instance, but since the property has been overwritten, it now gives false results:

    duck.constructor === Bird;
    duck.constructor === Object;
    duck instanceof Bird;
    In order, these expressions would evaluate to false, true, and true.

    To fix this, whenever a prototype is manually set to a new object, remember to define the constructor property:

    Bird.prototype = {
    constructor: Bird,
    numLegs: 2,
    eat: function() {
        console.log("nom nom nom");
    },
    describe: function() {
        console.log("My name is " + this.name); 
    }
    };

>Understand Where an Object’s Prototype Comes From<
    Just like people inherit genes from their parents, an object inherits its prototype directly from the constructor function that created it. For example, here the Bird constructor creates 
    the duck object:

        function Bird(name) {
        this.name = name;
        }

        let duck = new Bird("Donald");

    duck inherits its prototype from the Bird constructor function. You can show this relationship with the isPrototypeOf method:

        Bird.prototype.isPrototypeOf(duck);
    
    This would return true.

>Understand the Prototype Chain<

    All objects in JavaScript (with a few exceptions) have a prototype. Also, an object’s prototype itself is an object.

        function Bird(name) {
        this.name = name;
        }

        typeof Bird.prototype;

    Because a prototype is an object, a prototype can have its own prototype! In this case, the prototype of Bird.prototype is Object.prototype:

        Object.prototype.isPrototypeOf(Bird.prototype);

    How is this useful? You may recall the hasOwnProperty method from a previous challenge:

        let duck = new Bird("Donald");
        duck.hasOwnProperty("name");

    The hasOwnProperty method is defined in Object.prototype, which can be accessed by Bird.prototype, which can then be accessed by duck. This is an example of the prototype chain. 
    In this prototype chain, Bird is the supertype for duck, while duck is the subtype. Object is a supertype for both Bird and duck. Object is a supertype for all objects in JavaScript. 
    Therefore, any object can use the hasOwnProperty method.

>Inherit Behaviors from a Supertype<
    In the previous challenge, you created a supertype called Animal that defined behaviors shared by all animals:

        function Animal() { }
        Animal.prototype.eat = function() {
        console.log("nom nom nom");
        };
        
    This and the next challenge will cover how to reuse the methods of Animal inside Bird and Dog without defining them again. It uses a technique called inheritance. This challenge 
    covers the first step: make an instance of the supertype (or parent). You already know one way to create an instance of Animal using the new operator:

        let animal = new Animal();

    There are some disadvantages when using this syntax for inheritance, which are too complex for the scope of this challenge. Instead, here's an alternative approach without those 
    disadvantages:

        let animal = Object.create(Animal.prototype);

    Object.create(obj) creates a new object, and sets obj as the new object's prototype. Recall that the prototype is like the "recipe" for creating an object. By setting the prototype
    of animal to be the prototype of Animal, you are effectively giving the animal instance the same "recipe" as any other instance of Animal.

        animal.eat();
        animal instanceof Animal;

    The instanceof method here would return true.

>Set the Child's Prototype to an Instance of the Parent<
    In the previous challenge you saw the first step for inheriting behavior from the supertype (or parent) Animal: making a new instance of Animal.

    This challenge covers the next step: set the prototype of the subtype (or child)—in this case, Bird—to be an instance of Animal.

        Bird.prototype = Object.create(Animal.prototype);

    Remember that the prototype is like the "recipe" for creating an object. In a way, the recipe for Bird now includes all the key "ingredients" from Animal.

        let duck = new Bird("Donald");
        duck.eat();

    duck inherits all of Animal's properties, including the eat method.

>Reset an Inherited Constructor Property<

    When an object inherits its prototype from another object, it also inherits the supertype's constructor property.

    Here's an example:

        function Bird() { }
        Bird.prototype = Object.create(Animal.prototype);
        let duck = new Bird();
        duck.constructor

    But duck and all instances of Bird should show that they were constructed by Bird and not Animal. To do so, you can manually set the constructor property of Bird to the Bird object:

    Bird.prototype.constructor = Bird;
    duck.constructor

>Add Methods After Inheritance<
    A constructor function that inherits its prototype object from a supertype constructor function can still have its own methods in addition to inherited methods.

    For example, Bird is a constructor that inherits its prototype from Animal:

        function Animal() { }
        Animal.prototype.eat = function() {
        console.log("nom nom nom");
        };
        function Bird() { }
        Bird.prototype = Object.create(Animal.prototype);
        Bird.prototype.constructor = Bird;

    In addition to what is inherited from Animal, you want to add behavior that is unique to Bird objects. Here, Bird will get a fly() function. Functions are added to Bird's prototype the 
    same way as any constructor function:

        Bird.prototype.fly = function() {
        console.log("I'm flying!");
        };

    Now instances of Bird will have both eat() and fly() methods:

        let duck = new Bird();
        duck.eat();
        duck.fly();

    duck.eat() would display the string nom nom nom in the console, and duck.fly() would display the string I'm flying!.

>Override Inherited Methods<
    In previous lessons, you learned that an object can inherit its behavior (methods) from another object by referencing its prototype object:

        ChildObject.prototype = Object.create(ParentObject.prototype);

    Then the ChildObject received its own methods by chaining them onto its prototype:

        ChildObject.prototype.methodName = function() {...};

    It's possible to override an inherited method. It's done the same way - by adding a method to ChildObject.prototype using the same method name as the one to override. Here's an example of 
    Bird overriding the eat() method inherited from Animal:

        function Animal() { }
        Animal.prototype.eat = function() {
        return "nom nom nom";
        };
        function Bird() { }

        Bird.prototype = Object.create(Animal.prototype);

        Bird.prototype.eat = function() {
        return "peck peck peck";
        };

    If you have an instance let duck = new Bird(); and you call duck.eat(), this is how JavaScript looks for the method on the prototype chain of duck:

        duck => Is eat() defined here? No.
        Bird => Is eat() defined here? => Yes. Execute it and stop searching.
        Animal => eat() is also defined, but JavaScript stopped searching before reaching this level.
        Object => JavaScript stopped searching before reaching this level.

>Use a Mixin to Add Common Behavior Between Unrelated Objects<

    As you have seen, behavior is shared through inheritance. However, there are cases when inheritance is not the best solution. Inheritance does not work well for unrelated objects like Bird and 
    Airplane. They can both fly, but a Bird is not a type of Airplane and vice versa.

    For unrelated objects, it's better to use mixins. A mixin allows other objects to use a collection of functions.

        let flyMixin = function(obj) {
        obj.fly = function() {
            console.log("Flying, wooosh!");
        }
        };

    The flyMixin takes any object and gives it the fly method.

        let bird = {
        name: "Donald",
        numLegs: 2
        };

        let plane = {
        model: "777",
        numPassengers: 524
        };

        flyMixin(bird);
        flyMixin(plane);

    Here bird and plane are passed into flyMixin, which then assigns the fly function to each object. Now bird and plane can both fly:

        bird.fly();
        plane.fly();

    The console would display the string Flying, wooosh! twice, once for each .fly() call.

    Note how the mixin allows for the same fly method to be reused by unrelated objects bird and plane.

>Use Closure to Protect Properties Within an Object from Being Modified Externally<

    In the previous challenge, bird had a public property name. It is considered public because it can be accessed and changed outside of bird's definition.

        bird.name = "Duffy";

    Therefore, any part of your code can easily change the name of bird to any value. Think about things like passwords and bank accounts being easily changeable by any part of your codebase. 
    That could cause a lot of issues.

    The simplest way to make this public property private is by creating a variable within the constructor function. This changes the scope of that variable to be within the constructor 
    function versus available globally. This way, the variable can only be accessed and changed by methods also within the constructor function.

        function Bird() {
        let hatchedEgg = 10;

        this.getHatchedEggCount = function() { 
            return hatchedEgg;
        };
        }
        let ducky = new Bird();
        ducky.getHatchedEggCount();

    Here getHatchedEggCount is a privileged method, because it has access to the private variable hatchedEgg. This is possible because hatchedEgg is declared in the same context as 
    getHatchedEggCount. In JavaScript, a function always has access to the context in which it was created. This is called closure.

>The prototype<
    1.All objects in JavaScript have a prototype:
        *You can check the object’s prototype by using the Object.getPrototypeOf() function on the object, like Object.getPrototypeOf(player1).
        
        *The return value (result) of this function refers to the .prototype property of the Object Constructor 
            (i.e., Player(name, marker)) - Object.getPrototypeOf(player1) === Player.prototype.
        
    2.The prototype is another object:
        *The value of the Object Constructor’s .prototype property (i.e., Player.prototype) contains the prototype object.
        *The reference to this value of Player.prototype is stored in every Player object, every time a Player object is created.
        *Hence, you get a true value returned when you check the Objects prototype - Object.getPrototypeOf(player1) === Player.prototype.

    3.…that the original object inherits from, and has access to all of its prototype’s methods and properties:
        *As said in the earlier point, every Player object has a value which refers to Player.prototype. 
        So: Object.getPrototypeOf(player1) === Object.getPrototypeOf(player2) (returns true).

        *So, any properties or methods defined on Player.prototype will be available to the created Player objects!

    The last sub-item needs a little more explanation. What does defining ‘on the prototype’ mean? Consider the following code:

        Player.prototype.sayHello = function() {
        console.log("Hello, I'm a player!");
        }

        player1.sayHello() // logs "Hello, I'm a player!"
        player2.sayHello() // logs "Hello, I'm a player!"

        Here, we defined the .sayHello function ‘on’ the Player.prototype object. It then became available for the player1 and the player2 objects to use! 
        Similarly, you can attach other properties or functions you want to use on all Player objects by defining them on the objects’ prototype 
        (Player.prototype).

                    ----------------------------------------------------------------------------------------------------------------
                                                NOTE: How to Create a Constructor Function?
                                                    function Particle() {
                                                        this.x = 100;
                                                        this.y = 99;
                                                    }

                                                        Particle is our Constructor.
                                                        x and y is our properties.
                                                        
                    functions can be executed in slightly different way as console function if you use the 'new' keyword
                    the 'new' keyword says, "execute that function as a constructor function." meaning make a new object and assign
                    that (var p = new Particle) object to the keyword 'this'.
                    ----------------------------------------------------------------------------------------------------------------

>What’s wrong with constructors?<
    One of the biggest issues with constructors is that while they look just like regular functions, they do not behave like regular functions at all. If you try to use a constructor function 
    without the new keyword, your program will not work as expected, but it won’t produce error messages that are easy to trace.

>Factory function introduction<
    The factory function pattern is similar to constructors, but instead of using new to create an object, factory functions simply set up and return the new object when you call the function. 
    Check out this example:

        const personFactory = (name, age) => {
        const sayHello = () => console.log('hello!');
        return { name, age, sayHello };
        };

        const jeff = personFactory('jeff', 27);

        console.log(jeff.name); // 'jeff'

        jeff.sayHello(); // calls the function and logs 'hello!'

    For reference, here is the same thing created using the constructor pattern:

        const Person = function(name, age) {
        this.sayHello = () => console.log('hello!');
        this.name = name;
        this.age = age;
        };

        const jeff = new Person('jeff', 27);
    ----------------------------------------------------------------
    Note that factory functions do not utilize the prototype, which does come with a performance penalty. However, as a general rule, this penalty isn’t significant unless you’re creating 
    thousands of objects.
    ----------------------------------------------------------------

>Inheritance with factories<
    In the constructors lesson, we looked fairly deeply into the concept of prototypes and inheritance, or giving our objects access to the methods and properties of another object. There are 
    a few easy ways to accomplish this while using factories. Check this one out:

        const Person = (name) => {
        const sayName = () => console.log(`my name is ${name}`);
        return {sayName};
        }

        const Nerd = (name) => {
        // simply create a person and pull out the sayName function with destructuring assignment syntax!
        const {sayName} = Person(name);
        const doSomethingNerdy = () => console.log('nerd stuff');
        return {sayName, doSomethingNerdy};
        }

        const jeff = Nerd('jeff');

        jeff.sayName(); // my name is jeff
        jeff.doSomethingNerdy(); // nerd stuff

    This pattern is great because it allows you to pick and choose which functions you want to include in your new object. If you want to go ahead and lump ALL of another object in, you can 
    certainly do that as well with Object.assign

        const Nerd = (name) => {
        const prototype = Person(name);
        const doSomethingNerdy = () => console.log('nerd stuff');
        return Object.assign({}, prototype, {doSomethingNerdy});
        }

>Delegation / Differential Inheritance<
    A delegate prototype is an object that serves as a base for another object. When you inherit from a delegate prototype, the new object gets a reference to the prototype.

    When you try to access a property on the new object, it checks the object’s own properties first. If it doesn’t find it there, it checks the `[[Prototype]]`, and so on up the prototype 
    chain until it gets back to `Object.prototype`, which is the root delegate for most objects.

    Method delegation can preserve memory resources because you only need one copy of each method to be shared by all instances. There are several ways to set up the relationship in JavaScript.
    The one you’re likely to see in ES6 goes something like this:

        class Greeter {
        constructor (name) {
            this.name = name || 'John Doe';
        }
        hello () {
            return `Hello, my name is ${ this.name }`;
        }
        }

        const george = new Greeter('George');

        const msg = george.hello();

        console.log(msg); // Hello, my name is George

    Due to the many problems associated with class inheritance, and the temptation to extend classes, I don’t recommend this technique. I present it here only because it’s likely to be a 
    familiar point of reference.

    You may also be familiar with the ES5 constructor function version:

        function Greeter (name) {
        this.name = name || 'John Doe';
        }

        Greeter.prototype.hello = function hello () {
        return 'Hello, my name is ' + this.name;
        }

        var george = new Greeter('George');

        var msg = george.hello();

        console.log(msg); // Hello, my name is George

    I prefer a factory function using `Object.create()`. (In JavaScript, any function can create new objects. When it’s not a constructor function, it’s called a factory function):
 
        const proto = {
        hello () {
            return `Hello, my name is ${ this.name }`;
        }
        };

        const greeter = (name) => Object.assign(Object.create(proto), {
        name
        });

        const george = greeter('george');

        const msg = george.hello();

        console.log(msg);

    You can avoid property delegation by setting the prototype to `null` using `Object.create(null)`.

    One major drawback to delegation is that it’s not very good for storing state. If you try to store state as objects or arrays, mutating any member of the object or array will mutate the 
    member for every instance that shares the prototype. In order to preserve instance safety, you need to make a copy of the state for each object.

>The module pattern<
    Module is created as an IIFE (immediately invoked function expression) with a function inside:

        const SomeModule = (function() {})();

    Quick side note: ES6 introduced a new feature in JavaScript called ‘modules’. These are essentially a syntax for importing and exporting code between different JavaScript files. They’re 
    very powerful and we WILL be covering them later.

    Modules are actually very similar to factory functions. The main difference is how they’re created.A module is a construct somewhat similar to a singleton class. It has only one instance 
    and exposes its members, but it doesn’t have any kind of internal state.

    Meet a module:

        const calculator = (() => {
        const add = (a, b) => a + b;
        const sub = (a, b) => a - b;
        const mul = (a, b) => a * b;
        const div = (a, b) => a / b;
        return {
            add,
            sub,
            mul,
            div,
        };
        })();

        calculator.add(3,5); // 8
        calculator.sub(6,2); // 4
        calculator.mul(14,5534); // 77476

        The concepts are exactly the same as the factory function. However, instead of creating a factory that we can use over and over again to create multiple objects, the module pattern 
        wraps the factory in an IIFE (Immediately Invoked Function Expression).

        what is IIFE (Immediately Invoked Function Expression) >> The concept is simple: write a function, wrap it in parentheses, and then immediately call the function by adding () to the 
        end of it.

>Scope<
    Scope: Scope means variable access which is when a piece of code is running, what variable do I have access to.
    context: Whenever a piece of code is running the value of 'this' is the context.

    What is Global Scope?
        Before you write a line of JavaScript, you’re in what we call the Global Scope. If we declare a variable, it’s defined globally:

        // global scope
        var name = 'Todd';

    What is Local Scope?
        A local scope refers to any scope defined past the global scope. There is typically one global scope, and each function defined has its own (nested) local scope. Any function defined 
        within another function has a local scope which is linked to the outer function.

    Scope
        it works like parents and children. When you're talking about cookies, If Im a parent and I go out buy a box of cookies, by default my child gets access to the cookies. Because they're
        in the parent they're my child. Now if my child saves up his hard-earned money and buys his own cookies there is no way that he is going to allow me(parent) access to his cookies.That
        is exactly how variable access/how scope works in JavaScript.

        So when I create a child variable, the parent does not have access to it but I have access to "a" in function.If we console.log(a); inside the function, it will work and we'll get the
        result of "1" in the console.

            //parent - cookies >>> var a = 1;
            
            function foo() {
            //children - cookies >>> var b = 2;   
            }
            foo();
            console.log(b); >>>>>> if we console.log(b); it's gonna say b is undefined.

            I have access to a but the parent scope does not have access to b.

        Now look at the another example:

            I've defined a variable in my child scope that is the exact same name as a variable in my parent scope.It's not legal but all that's happened is, is now I have two "a" variables in
            existence.

            I have a "window.a" (584) and I have a within this child scope (588). So now I have broken the connection, I have no way of accessing the a that is outside unless I know how to get
            to its parent object which is window.a

            var a = 1;  <<< (windows.a)
            //parent - cookies

            function foo() {
            //children - cookies >>> var a = 2;
            console.log(window.a); <<< this will show "1" in the console.
            console.log(a);        <<< this will show "2" in the console.
            }
            foo();

            now let me do one more thing here:+

                So after I run foo(); and console log (a), it will show "1" in the console which is the value of a in parent scope. I ran foo(); and it created a new variable called "a" but
                it did not touch the "a" in my parent scope. "a" is still the value of "1".

                var a = 1;

                function foo() {
                    var a = 2;
                }
                foo();
                console.log(a);

                if we take off the var inside of function (603) JavaScript will think like this: it going to first look in the scope that Im in and say "has a variable "a" been created yet?
                Okay it has been created so now this "a"(616) changes this "a" (614), so now this "a" (614) will be changed to a value of two and console.log will still console.log "1" (620) 
                in the console. 

                    var a = 1;

                    function foo() {
                        var a = 1; <<< (1)If I remove this

                        a = 2;  <<<  (2)JavaScript is going to look in my scope find out the "a" has not been defined so its going to look in my parent scope(612) and say "Ahh,there
                                     is an a" and now points to this (612) "a". then if we console.log(a) again (621) it will show "2" in the console.
                    }
                    foo();
                    console.log(a);

>Closure<
    when returning a function reference - a more practical usage. Inside our scope, we can return things so that they’re available in the parent scope:

        var sayHello = function (name) {
        var text = 'Hello, ' + name;
        return function () {
            console.log(text);
          };
        };

    The closure concept we’ve used here makes our scope inside sayHello inaccessible to the public scope. Calling the function alone will do nothing as it returns a function:

        sayHello('Todd'); // nothing happens, no errors, just silence...

    The function returns a function, which means it needs assignment, and then calling:

        var helloTodd = sayHello('Todd');
        helloTodd(); // will call the closure and log 'Hello, Todd'

    Okay, I lied, you can call it, and you may have seen functions like this, but this will call your closure:

        sayHello('Bob')(); // calls the returned function without assignment.





        


