>Define a Constructor Function<
    Constructors are functions that create new objects. They define properties and behaviors that will belong to the new object. Think of them as a 
    blueprint for the creation of new objects.

    Here is an example of a constructor:

        function Bird() {
        this.name = "Albert";
        this.color = "blue";
        this.numLegs = 2;
        }
    
            This constructor defines a Bird object with properties name, color, and numLegs set to Albert, blue, and 2, respectively. Constructors 
            follow a few conventions:

               * Constructors are defined with a capitalized name to distinguish them from other functions that are not constructors.
               * Constructors use the keyword 'this' to set properties of the object they will create. Inside the constructor, this refers to the new 
                object it will create.

               * Constructors define properties and behaviors instead of returning a value as other functions might.

>Use a Constructor to Create Objects<

    Here's the Bird constructor from the previous challenge:

        function Bird() {
        this.name = "Albert";
        this.color  = "blue";
        this.numLegs = 2;
        }

        let blueBird = new Bird();

    NOTE: this inside the constructor always refers to the object being created.

    Notice that the new operator is used when calling a constructor. This tells JavaScript to create a new instance of Bird called blueBird. 
    Without the new operator, this inside the constructor would not point to the newly created object, giving unexpected results. Now blueBird has 
    all the properties defined inside the Bird constructor:

        blueBird.name;
        blueBird.color;
        blueBird.numLegs;
        Just like any other object, its properties can be accessed and modified:

        blueBird.name = 'Elvira';
        blueBird.name;

>Extend Constructors to Receive Arguments<
    The Bird and Dog constructors from the last challenge worked well. However, notice that all Birds that are created with the Bird constructor 
    are automatically named Albert, are blue in color, and have two legs. What if you want birds with different values for name and color? 
    It's possible to change the properties of each bird manually but that would be a lot of work:

        let swan = new Bird();
        swan.name = "Carlos";
        swan.color = "white";

    Suppose you were writing a program to keep track of hundreds or even thousands of different birds in an aviary. It would take a lot of time to 
    create all the birds, then change the properties to different values for every one. To more easily create different Bird objects, you can design 
    your Bird constructor to accept parameters:

        function Bird(name, color) {
        this.name = name;
        this.color = color;
        this.numLegs = 2;
        }

    Then pass in the values as arguments to define each unique bird into the Bird constructor: let cardinal = new Bird("Bruce", "red"); This gives a 
    new instance of Bird with name and color properties set to Bruce and red, respectively. The numLegs property is still set to 2. The cardinal has 
    these properties:

        cardinal.name
        cardinal.color
        cardinal.numLegs

    The constructor is more flexible. It's now possible to define the properties for each Bird at the time it is created, which is one way that 
    JavaScript constructors are so useful. They group objects together based on shared characteristics and behavior and define a blueprint that 
    automates their creation.

>Verify an Object's Constructor with 'instanceof'<

    Anytime a constructor function creates a new object, that object is said to be an instance of its constructor. JavaScript gives a convenient 
    way to verify this with the instanceof operator. instanceof allows you to compare an object to a constructor, returning true or false based on 
    whether or not that object was created with the constructor. Here's an example:

        let Bird = function(name, color) {
        this.name = name;
        this.color = color;
        this.numLegs = 2;
        }

        let crow = new Bird("Alexis", "black");

        crow instanceof Bird;

    This instanceof method would return true.

    If an object is created without using a constructor, instanceof will verify that it is not an instance of that constructor:

        let canary = {
        name: "Mildred",
        color: "Yellow",
        numLegs: 2
        };

        canary instanceof Bird;
    
    This instanceof method would return false.

>Understand Own Properties<

    In the following example, the Bird constructor defines two properties: name and numLegs:

        function Bird(name) {
        this.name = name;
        this.numLegs = 2;
        }

        let duck = new Bird("Donald");
        let canary = new Bird("Tweety");

    name and numLegs are called own properties, because they are defined directly on the instance object. That means that duck and canary each has its 
    own separate copy of these properties. In fact every instance of Bird will have its own copy of these properties. The following code adds all of 
    the own properties of duck to the array ownProps:

        let ownProps = [];

        for (let property in duck) {
        if(duck.hasOwnProperty(property)) {
            ownProps.push(property);
        }
        }

        console.log(ownProps);

    The console would display the value ["name", "numLegs"].

>Use Prototype Properties to Reduce Duplicate Code<

    Since numLegs will probably have the same value for all instances of Bird, you essentially have a duplicated variable numLegs inside each Bird instance.

    This may not be an issue when there are only two instances, but imagine if there are millions of instances. That would be a lot of duplicated variables.

    A better way is to use the prototype of Bird. Properties in the prototype are shared among ALL instances of Bird. Here's how to add numLegs to the Bird prototype:

        Bird.prototype.numLegs = 2;

    Now all instances of Bird have the numLegs property.

        console.log(duck.numLegs);
        console.log(canary.numLegs);

    Since all instances automatically have the properties on the prototype, think of a prototype as a "recipe" for creating objects. Note that the prototype for duck and canary is 
    part of the Bird constructor as Bird.prototype.

>Iterate Over All Properties<

    You have now seen two kinds of properties: own properties and prototype properties. Own properties are defined directly on the object instance itself. And prototype properties are 
    defined on the prototype.

        function Bird(name) {
        this.name = name;  //own property
        }

        Bird.prototype.numLegs = 2; // prototype property

        let duck = new Bird("Donald");

    Here is how you add duck's own properties to the array ownProps and prototype properties to the array prototypeProps:

        let ownProps = [];
        let prototypeProps = [];

        for (let property in duck) {
        if(duck.hasOwnProperty(property)) {
            ownProps.push(property);
        } else {
            prototypeProps.push(property);
        }
        }

        console.log(ownProps);
        console.log(prototypeProps);

    console.log(ownProps) would display ["name"] in the console, and console.log(prototypeProps) would display ["numLegs"].

>Understand the Constructor Property<

    There is a special constructor property located on the object instances duck and beagle that were created in the previous challenges:

        let duck = new Bird();
        let beagle = new Dog();

        console.log(duck.constructor === Bird); 
        console.log(beagle.constructor === Dog);

    Both of these console.log calls would display true in the console.

    Note that the constructor property is a reference to the constructor function that created the instance. The advantage of the constructor property is that it's possible to check 
    for this property to find out what kind of object it is. Here's an example of how this could be used:

        function joinBirdFraternity(candidate) {
        if (candidate.constructor === Bird) {
            return true;
        } else {
            return false;
        }
        }

    Note: Since the constructor property can be overwritten (which will be covered in the next two challenges) itâ€™s generally better to use the instanceof method to check the type of 
    an object.

>Change the Prototype to a New Object<

    Up until now you have been adding properties to the prototype individually:

        Bird.prototype.numLegs = 2;
        This becomes tedious after more than a few properties.

        Bird.prototype.eat = function() {
        console.log("nom nom nom");
        }

        Bird.prototype.describe = function() {
        console.log("My name is " + this.name);
        }

    A more efficient way is to set the prototype to a new object that already contains the properties. This way, the properties are added all at once:

        Bird.prototype = {
        numLegs: 2, 
        eat: function() {
            console.log("nom nom nom");
        },
        describe: function() {
            console.log("My name is " + this.name);
        }
        };

>Remember to Set the Constructor Property when Changing the Prototype<
    There is one crucial side effect of manually setting the prototype to a new object. It erases the constructor property! This property can be used to check which constructor 
    function created the instance, but since the property has been overwritten, it now gives false results:

    duck.constructor === Bird;
    duck.constructor === Object;
    duck instanceof Bird;
    In order, these expressions would evaluate to false, true, and true.

    To fix this, whenever a prototype is manually set to a new object, remember to define the constructor property:

    Bird.prototype = {
    constructor: Bird,
    numLegs: 2,
    eat: function() {
        console.log("nom nom nom");
    },
    describe: function() {
        console.log("My name is " + this.name); 
    }
    };

>Understand Where an Objectâ€™s Prototype Comes From<
    Just like people inherit genes from their parents, an object inherits its prototype directly from the constructor function that created it. For example, here the Bird constructor creates the duck object:

        function Bird(name) {
        this.name = name;
        }

        let duck = new Bird("Donald");

    duck inherits its prototype from the Bird constructor function. You can show this relationship with the isPrototypeOf method:

        Bird.prototype.isPrototypeOf(duck);
    
    This would return true.

>Understand the Prototype Chain<

    All objects in JavaScript (with a few exceptions) have a prototype. Also, an objectâ€™s prototype itself is an object.

        function Bird(name) {
        this.name = name;
        }

        typeof Bird.prototype;

    Because a prototype is an object, a prototype can have its own prototype! In this case, the prototype of Bird.prototype is Object.prototype:

        Object.prototype.isPrototypeOf(Bird.prototype);

    How is this useful? You may recall the hasOwnProperty method from a previous challenge:

        let duck = new Bird("Donald");
        duck.hasOwnProperty("name");

    The hasOwnProperty method is defined in Object.prototype, which can be accessed by Bird.prototype, which can then be accessed by duck. This is an example of the prototype chain. 
    In this prototype chain, Bird is the supertype for duck, while duck is the subtype. Object is a supertype for both Bird and duck. Object is a supertype for all objects in JavaScript. 
    Therefore, any object can use the hasOwnProperty method.

>Inherit Behaviors from a Supertype<
    In the previous challenge, you created a supertype called Animal that defined behaviors shared by all animals:

        function Animal() { }
        Animal.prototype.eat = function() {
        console.log("nom nom nom");
        };
        
    This and the next challenge will cover how to reuse the methods of Animal inside Bird and Dog without defining them again. It uses a technique called inheritance. This challenge 
    covers the first step: make an instance of the supertype (or parent). You already know one way to create an instance of Animal using the new operator:

        let animal = new Animal();

    There are some disadvantages when using this syntax for inheritance, which are too complex for the scope of this challenge. Instead, here's an alternative approach without those 
    disadvantages:

        let animal = Object.create(Animal.prototype);

    Object.create(obj) creates a new object, and sets obj as the new object's prototype. Recall that the prototype is like the "recipe" for creating an object. By setting the prototype
    of animal to be the prototype of Animal, you are effectively giving the animal instance the same "recipe" as any other instance of Animal.

        animal.eat();
        animal instanceof Animal;

    The instanceof method here would return true.

>Set the Child's Prototype to an Instance of the Parent<
    In the previous challenge you saw the first step for inheriting behavior from the supertype (or parent) Animal: making a new instance of Animal.

    This challenge covers the next step: set the prototype of the subtype (or child)â€”in this case, Birdâ€”to be an instance of Animal.

        Bird.prototype = Object.create(Animal.prototype);

    Remember that the prototype is like the "recipe" for creating an object. In a way, the recipe for Bird now includes all the key "ingredients" from Animal.

        let duck = new Bird("Donald");
        duck.eat();

    duck inherits all of Animal's properties, including the eat method.

>Reset an Inherited Constructor Property<

    When an object inherits its prototype from another object, it also inherits the supertype's constructor property.

    Here's an example:

        function Bird() { }
        Bird.prototype = Object.create(Animal.prototype);
        let duck = new Bird();
        duck.constructor

    But duck and all instances of Bird should show that they were constructed by Bird and not Animal. To do so, you can manually set the constructor property of Bird to the Bird object:

    Bird.prototype.constructor = Bird;
    duck.constructor

>Add Methods After Inheritance<
    A constructor function that inherits its prototype object from a supertype constructor function can still have its own methods in addition to inherited methods.

    For example, Bird is a constructor that inherits its prototype from Animal:

        function Animal() { }
        Animal.prototype.eat = function() {
        console.log("nom nom nom");
        };
        function Bird() { }
        Bird.prototype = Object.create(Animal.prototype);
        Bird.prototype.constructor = Bird;

    In addition to what is inherited from Animal, you want to add behavior that is unique to Bird objects. Here, Bird will get a fly() function. Functions are added to Bird's prototype the 
    same way as any constructor function:

        Bird.prototype.fly = function() {
        console.log("I'm flying!");
        };

    Now instances of Bird will have both eat() and fly() methods:

        let duck = new Bird();
        duck.eat();
        duck.fly();

    duck.eat() would display the string nom nom nom in the console, and duck.fly() would display the string I'm flying!.

>Override Inherited Methods<
    In previous lessons, you learned that an object can inherit its behavior (methods) from another object by referencing its prototype object:

        ChildObject.prototype = Object.create(ParentObject.prototype);

    Then the ChildObject received its own methods by chaining them onto its prototype:

        ChildObject.prototype.methodName = function() {...};

    It's possible to override an inherited method. It's done the same way - by adding a method to ChildObject.prototype using the same method name as the one to override. Here's an example of 
    Bird overriding the eat() method inherited from Animal:

        function Animal() { }
        Animal.prototype.eat = function() {
        return "nom nom nom";
        };
        function Bird() { }

        Bird.prototype = Object.create(Animal.prototype);

        Bird.prototype.eat = function() {
        return "peck peck peck";
        };

    If you have an instance let duck = new Bird(); and you call duck.eat(), this is how JavaScript looks for the method on the prototype chain of duck:

        duck => Is eat() defined here? No.
        Bird => Is eat() defined here? => Yes. Execute it and stop searching.
        Animal => eat() is also defined, but JavaScript stopped searching before reaching this level.
        Object => JavaScript stopped searching before reaching this level.

>Use a Mixin to Add Common Behavior Between Unrelated Objects<

    As you have seen, behavior is shared through inheritance. However, there are cases when inheritance is not the best solution. Inheritance does not work well for unrelated objects like Bird and 
    Airplane. They can both fly, but a Bird is not a type of Airplane and vice versa.

    For unrelated objects, it's better to use mixins. A mixin allows other objects to use a collection of functions.

        let flyMixin = function(obj) {
        obj.fly = function() {
            console.log("Flying, wooosh!");
        }
        };

    The flyMixin takes any object and gives it the fly method.

        let bird = {
        name: "Donald",
        numLegs: 2
        };

        let plane = {
        model: "777",
        numPassengers: 524
        };

        flyMixin(bird);
        flyMixin(plane);

    Here bird and plane are passed into flyMixin, which then assigns the fly function to each object. Now bird and plane can both fly:

        bird.fly();
        plane.fly();

    The console would display the string Flying, wooosh! twice, once for each .fly() call.

    Note how the mixin allows for the same fly method to be reused by unrelated objects bird and plane.

>Use Closure to Protect Properties Within an Object from Being Modified Externally<

    In the previous challenge, bird had a public property name. It is considered public because it can be accessed and changed outside of bird's definition.

        bird.name = "Duffy";

    Therefore, any part of your code can easily change the name of bird to any value. Think about things like passwords and bank accounts being easily changeable by any part of your codebase. 
    That could cause a lot of issues.

    The simplest way to make this public property private is by creating a variable within the constructor function. This changes the scope of that variable to be within the constructor 
    function versus available globally. This way, the variable can only be accessed and changed by methods also within the constructor function.

        function Bird() {
        let hatchedEgg = 10;

        this.getHatchedEggCount = function() { 
            return hatchedEgg;
        };
        }
        let ducky = new Bird();
        ducky.getHatchedEggCount();

    Here getHatchedEggCount is a privileged method, because it has access to the private variable hatchedEgg. This is possible because hatchedEgg is declared in the same context as 
    getHatchedEggCount. In JavaScript, a function always has access to the context in which it was created. This is called closure.

>The prototype<
    1.All objects in JavaScript have a prototype:
        *You can check the objectâ€™s prototype by using the Object.getPrototypeOf() function on the object, like Object.getPrototypeOf(player1).
        
        *The return value (result) of this function refers to the .prototype property of the Object Constructor 
            (i.e., Player(name, marker)) - Object.getPrototypeOf(player1) === Player.prototype.
        
    2.The prototype is another object:
        *The value of the Object Constructorâ€™s .prototype property (i.e., Player.prototype) contains the prototype object.
        *The reference to this value of Player.prototype is stored in every Player object, every time a Player object is created.
        *Hence, you get a true value returned when you check the Objects prototype - Object.getPrototypeOf(player1) === Player.prototype.

    3.â€¦that the original object inherits from, and has access to all of its prototypeâ€™s methods and properties:
        *As said in the earlier point, every Player object has a value which refers to Player.prototype. 
        So: Object.getPrototypeOf(player1) === Object.getPrototypeOf(player2) (returns true).

        *So, any properties or methods defined on Player.prototype will be available to the created Player objects!

    The last sub-item needs a little more explanation. What does defining â€˜on the prototypeâ€™ mean? Consider the following code:

        Player.prototype.sayHello = function() {
        console.log("Hello, I'm a player!");
        }

        player1.sayHello() // logs "Hello, I'm a player!"
        player2.sayHello() // logs "Hello, I'm a player!"

        Here, we defined the .sayHello function â€˜onâ€™ the Player.prototype object. It then became available for the player1 and the player2 objects to use! 
        Similarly, you can attach other properties or functions you want to use on all Player objects by defining them on the objectsâ€™ prototype 
        (Player.prototype).

                    ----------------------------------------------------------------------------------------------------------------
                                                NOTE: How to Create a Constructor Function?
                                                    function Particle() {
                                                        this.x = 100;
                                                        this.y = 99;
                                                    }

                                                        Particle is our Constructor.
                                                        x and y is our properties.
                                                        
                    functions can be executed in slightly different way as console function if you use the 'new' keyword
                    the 'new' keyword says, "execute that function as a constructor function." meaning make a new object and assign
                    that (var p = new Particle) object to the keyword 'this'.
                    ----------------------------------------------------------------------------------------------------------------

>Whatâ€™s wrong with constructors?<
    One of the biggest issues with constructors is that while they look just like regular functions, they do not behave like regular functions at all. If you try to use a constructor function 
    without the new keyword, your program will not work as expected, but it wonâ€™t produce error messages that are easy to trace.

>Factory function introduction<
    The factory function pattern is similar to constructors, but instead of using new to create an object, factory functions simply set up and return the new object when you call the function. 
    Check out this example:

        const personFactory = (name, age) => {
        const sayHello = () => console.log('hello!');
        return { name, age, sayHello };
        };

        const jeff = personFactory('jeff', 27);

        console.log(jeff.name); // 'jeff'

        jeff.sayHello(); // calls the function and logs 'hello!'

    For reference, here is the same thing created using the constructor pattern:

        const Person = function(name, age) {
        this.sayHello = () => console.log('hello!');
        this.name = name;
        this.age = age;
        };

        const jeff = new Person('jeff', 27);
    ----------------------------------------------------------------
    Note that factory functions do not utilize the prototype, which does come with a performance penalty. However, as a general rule, this penalty isnâ€™t significant unless youâ€™re creating 
    thousands of objects.
    ----------------------------------------------------------------

>Inheritance with factories<
    In the constructors lesson, we looked fairly deeply into the concept of prototypes and inheritance, or giving our objects access to the methods and properties of another object. There are 
    a few easy ways to accomplish this while using factories. Check this one out:

        const Person = (name) => {
        const sayName = () => console.log(`my name is ${name}`);
        return {sayName};
        }

        const Nerd = (name) => {
        // simply create a person and pull out the sayName function with destructuring assignment syntax!
        const {sayName} = Person(name);
        const doSomethingNerdy = () => console.log('nerd stuff');
        return {sayName, doSomethingNerdy};
        }

        const jeff = Nerd('jeff');

        jeff.sayName(); // my name is jeff
        jeff.doSomethingNerdy(); // nerd stuff

    This pattern is great because it allows you to pick and choose which functions you want to include in your new object. If you want to go ahead and lump ALL of another object in, you can 
    certainly do that as well with Object.assign

        const Nerd = (name) => {
        const prototype = Person(name);
        const doSomethingNerdy = () => console.log('nerd stuff');
        return Object.assign({}, prototype, {doSomethingNerdy});
        }

>Delegation / Differential Inheritance<
    A delegate prototype is an object that serves as a base for another object. When you inherit from a delegate prototype, the new object gets a reference to the prototype.

    When you try to access a property on the new object, it checks the objectâ€™s own properties first. If it doesnâ€™t find it there, it checks the `[[Prototype]]`, and so on up the prototype 
    chain until it gets back to `Object.prototype`, which is the root delegate for most objects.

    Method delegation can preserve memory resources because you only need one copy of each method to be shared by all instances. There are several ways to set up the relationship in JavaScript.
    The one youâ€™re likely to see in ES6 goes something like this:

        class Greeter {
        constructor (name) {
            this.name = name || 'John Doe';
        }
        hello () {
            return `Hello, my name is ${ this.name }`;
        }
        }

        const george = new Greeter('George');

        const msg = george.hello();

        console.log(msg); // Hello, my name is George

    Due to the many problems associated with class inheritance, and the temptation to extend classes, I donâ€™t recommend this technique. I present it here only because itâ€™s likely to be a 
    familiar point of reference.

    You may also be familiar with the ES5 constructor function version:

        function Greeter (name) {
        this.name = name || 'John Doe';
        }

        Greeter.prototype.hello = function hello () {
        return 'Hello, my name is ' + this.name;
        }

        var george = new Greeter('George');

        var msg = george.hello();

        console.log(msg); // Hello, my name is George

    I prefer a factory function using `Object.create()`. (In JavaScript, any function can create new objects. When itâ€™s not a constructor function, itâ€™s called a factory function):
 
        const proto = {
        hello () {
            return `Hello, my name is ${ this.name }`;
        }
        };

        const greeter = (name) => Object.assign(Object.create(proto), {
        name
        });

        const george = greeter('george');

        const msg = george.hello();

        console.log(msg);

    You can avoid property delegation by setting the prototype to `null` using `Object.create(null)`.

    One major drawback to delegation is that itâ€™s not very good for storing state. If you try to store state as objects or arrays, mutating any member of the object or array will mutate the 
    member for every instance that shares the prototype. In order to preserve instance safety, you need to make a copy of the state for each object.

>The module pattern<
    Module is created as an IIFE (immediately invoked function expression) with a function inside:

        const SomeModule = (function() {})();

    Quick side note: ES6 introduced a new feature in JavaScript called â€˜modulesâ€™. These are essentially a syntax for importing and exporting code between different JavaScript files. Theyâ€™re 
    very powerful and we WILL be covering them later.

    Modules are actually very similar to factory functions. The main difference is how theyâ€™re created.A module is a construct somewhat similar to a singleton class. It has only one instance 
    and exposes its members, but it doesnâ€™t have any kind of internal state.

    Meet a module:

        const calculator = (() => {
        const add = (a, b) => a + b;
        const sub = (a, b) => a - b;
        const mul = (a, b) => a * b;
        const div = (a, b) => a / b;
        return {
            add,
            sub,
            mul,
            div,
        };
        })();

        calculator.add(3,5); // 8
        calculator.sub(6,2); // 4
        calculator.mul(14,5534); // 77476

        The concepts are exactly the same as the factory function. However, instead of creating a factory that we can use over and over again to create multiple objects, the module pattern 
        wraps the factory in an IIFE (Immediately Invoked Function Expression).

        what is IIFE (Immediately Invoked Function Expression) >> The concept is simple: write a function, wrap it in parentheses, and then immediately call the function by adding () to the 
        end of it.





>Scope<
    Scope: Scope means variable access which is when a piece of code is running, what variable do I have access to.
    context: Whenever a piece of code is running the value of 'this' is the context.

    What is Global Scope?
        Before you write a line of JavaScript, youâ€™re in what we call the Global Scope. If we declare a variable, itâ€™s defined globally:

        // global scope
        var name = 'Todd';

    What is Local Scope?
        A local scope refers to any scope defined past the global scope. There is typically one global scope, and each function defined has its own (nested) local scope. Any function defined 
        within another function has a local scope which is linked to the outer function.

    Scope
        it works like parents and children. When you're talking about cookies, If Im a parent and I go out buy a box of cookies, by default my child gets access to the cookies. Because they're
        in the parent they're my child. Now if my child saves up his hard-earned money and buys his own cookies there is no way that he is going to allow me(parent) access to his cookies.That
        is exactly how variable access/how scope works in JavaScript.

        So when I create a child variable, the parent does not have access to it but I have access to "a" in function.If we console.log(a); inside the function, it will work and we'll get the
        result of "1" in the console.

            //parent - cookies >>> var a = 1;
            
            function foo() {
            //children - cookies >>> var b = 2;   
            }
            foo();
            console.log(b); >>>>>> if we console.log(b); it's gonna say b is undefined.

            I have access to a but the parent scope does not have access to b.

        Now look at the another example:

            I've defined a variable in my child scope that is the exact same name as a variable in my parent scope.It's not legal but all that's happened is, is now I have two "a" variables in
            existence.

            I have a "window.a" (584) and I have a within this child scope (588). So now I have broken the connection, I have no way of accessing the a that is outside unless I know how to get
            to its parent object which is window.a

            var a = 1;  <<< (windows.a)
            //parent - cookies

            function foo() {
            //children - cookies >>> var a = 2;
            console.log(window.a); <<< this will show "1" in the console.
            console.log(a);        <<< this will show "2" in the console.
            }
            foo();

            now let me do one more thing here:+

                So after I run foo(); and console log (a), it will show "1" in the console which is the value of a in parent scope. I ran foo(); and it created a new variable called "a" but
                it did not touch the "a" in my parent scope. "a" is still the value of "1".

                var a = 1;

                function foo() {
                    var a = 2;
                }
                foo();
                console.log(a);

                if we take off the var inside of function (603) JavaScript will think like this: it going to first look in the scope that Im in and say "has a variable "a" been created yet?
                Okay it has been created so now this "a"(616) changes this "a" (614), so now this "a" (614) will be changed to a value of two and console.log will still console.log "1" (620) 
                in the console. 

                    var a = 1;

                    function foo() {
                        var a = 1; <<< (1)If I remove this

                        a = 2;  <<<  (2)JavaScript is going to look in my scope find out the "a" has not been defined so its going to look in my parent scope(612) and say "Ahh,there
                                     is an a" and now points to this (612) "a". then if we console.log(a) again (621) it will show "2" in the console.
                    }
                    foo();
                    console.log(a);

>Closure<
    when returning a function reference - a more practical usage. Inside our scope, we can return things so that theyâ€™re available in the parent scope:

        var sayHello = function (name) {
        var text = 'Hello, ' + name;
        return function () {
            console.log(text);
          };
        };

    The closure concept weâ€™ve used here makes our scope inside sayHello inaccessible to the public scope. Calling the function alone will do nothing as it returns a function:

        sayHello('Todd'); // nothing happens, no errors, just silence...

    The function returns a function, which means it needs assignment, and then calling:

        var helloTodd = sayHello('Todd');
        helloTodd(); // will call the closure and log 'Hello, Todd'

    Okay, I lied, you can call it, and you may have seen functions like this, but this will call your closure:

        sayHello('Bob')(); // calls the returned function without assignment.





        


